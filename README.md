# Nimbora: Starknet Winter Hackathon
![Nimbora](https://github.com/0xSpaceShard/nimbora-starknet-winter-hackathon/assets/159255568/5a642b5f-9af2-47a1-b9d4-2876f50fd4ae)


If you want to include submodules automatically (recommended) please you command:

```sh
git clone --recurse-submodules git@github.com:0xSpaceShard/nimbora-hackathon.git
git submodule update --recursive  --force --remote
```

**IMPORTANT**
Before you run the command `./setup-deploy.sh` or `./start-relayer.sh` make sure to create `.env` file from `.env.example` and update the environment variables! **(Otherwise it won't work)**.

```sh
# REQUIRED Alchemy Starknet RPC url.
export ALCHEMY_RPC_URL=https://eth-goerli.g.alchemy.com/v2/xxx

# REQUIRED Alchemy Starknet RPC url.
export L2_ALCHEMY_RPC_URL=https://starknet-goerli.g.alchemy.com/v2/XXX

# REQUIRED Starknet 'Address' used on the L2 contract.
export L2_RELAYER_ADDRESS=0xxxx

# REQUIRED Starknet 'PK' used on the L2 contract.
export L2_RELAYER_PRIVATE_KEY=0xxxx

# REQUIRED Ethereum PK used to process batches.
export PRIVATE_KEY=0xXXX
```

### Deploy L1 and L2 contracts

You will find the L1 contracts [here](https://github.com/0xSpaceShard/nimbora_yields_l1)
or under submodules on nimbora_yield_l1
Follow the `README` to develop a bew Yield strategy, compile and deploy the contracts.

You will find the L2 contracts [here](https://github.com/0xSpaceShard/nimbora_yields_l2)
or under submodules on nimbora_yield_l2
Follow the `README` to compile, declare, and deploy the contracts.

First run `setup-deploy.sh`, this script will deploy the sDAI strategy on Goerli and Starknet.


## Run Off-chain services
Nimbora Yield DEX off-chain services allow for the indexing and processing of L1 and L2 reports. For more details, please check this [link](https://github.com/0xSpaceShard/nimbora-relayer-public). It's important before to run the relayer to follow the documentation inside the repository.

Then run `start-relayer.sh`, to start the relayer. It's important to follow the README.md to connect the database with the Graphql service.

Finally when you are done run `stop-relayer.sh`.


## Yield DEX

### Problem

Users want to interact with their favourite DeFi protocols at a lowest possible prices and biggest possible yield. Even despite the cambrian explosion of new L2s Ethereum mainnet still remains the most secure and best place that contain the biggest and most mature DeFi protocols and what's most important has the biggest liquidity from all the L1 and L2s. Ethereum mainnet has a lots of users, which coverts to higher gas fees (because the blockspace is limited). With each passing day interacting with your favourite DeFi protocol becomes even more expensive as the gas (cost) required to do a simple stake, swap, or withdraw can cost 100s$ or even 1000$ of dollars.

### Solution

Nimbora Sync Yield allow users to access L1 yields from L2 without delay, additional gas fees and liquidity requirements (there are some constrains as we will see). This is made possible by pooling user liquidity and executing actions on behalf of them. On the tech side how we do it is to emit a share token representing of a mainnet yield token. Share price is updated at each report, which inform L2 of the yield generated by the L1 strategy.

### Contact architecture

<img width="1229" alt="Untitled (3)" src="https://github.com/0xSpaceShard/nimbora-hackathon/assets/127413534/7cc26cd7-23ee-4d22-94e0-5b4eccea6413">


### L2 Contracts

#### Pooling Manager

The pooling manager plays an intermediate role with L2 stratgies and L1 communication. The idea is to significantly reduce gas cost on L1 by hashing all of the data and mutualising bridge transfer. He is also responsible of registering all availaible strategies and is the only one able to process reports those. although he is processing all at once, he is also able to process only one report individually so broken strategy has not impact on others. 

#### Pooling Factory

The pooling factory is the contract used to deploy new “strategy packages”: token, token unstake and token manager, those contracts are the same for any strategies.

#### N-yield Token Manager

The token manager contains all the logic for token accountability through strategy report, setting the share price at each epoch. It is also the entrypoint for deposit and withdraw, only this contract is able to mint or burn token or unstake token 

#### N-yield Token

The nimbora yield token is the representation of the L1 strategy yield bearing token, increasing in value at each epoch. Once minted, it can be used in DeFi through the Starknet ecosystem (and beyond).

#### N-yield unstake nft

The nimbora yield unstake token is the representation of the token locked waiting for withdrawal being processed. In the case there is a liquidity user will get automatic withdrawal, otherwise they will have to wait.

### L1 Contracts

#### Pooling Manager

The pooling manager plays an intermediate role with L1 strategies and L2 communication. The contract receives a payload of data, containing all the information required to cover L2 strategies requests: deposit more in a strategy, inform the underlying NAV or withdraw some assets. 

#### Strategy handler

The strategy handler is an adapter used to interact with strategies, it receives a data of payload similar for each handler and processes the request before returning the new NAV of the strategy and potentially some ETH to bridge.

## Project Setup

## L1 and L2 Yield Dex Contracts
Nimbora Yield allows users to access L1 yields from L2 without delay, additional gas fees, and liquidity requirements. This is made possible by emitting a share token representing a layer one yield token. Share price is updated at each report, which informs L2 of the yield generated by the L1 strategy.

## Getting started with the code

We recommend you start with the setup-all.sh script and those steps so they environment can get setup.
